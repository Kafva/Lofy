// `module.exports` is equivilent to what will be reeturned from requiring()
// a module, in this case a function containing the definition of all the routes

// Note that requiring() the same package several times won't cause any overhead (cached)
const queryString = require('querystring');

module.exports = (fastify,functions,CONSTS) => 
{
    // Declare a handler for the favicon fetch
    fastify.get('/favicon.png', (request, reply) => 
    {
        return reply.sendFile("resc/favicon.png") 
    })

    //*** OAuth STEP 0 ***//
    fastify.get('/setstate', (request, reply) =>
    // Set state cookie
    {
        // To be able to verify that the response we recieve from spotify is valid
        // we save a cookie with the client containing the state,
        // when the client responds we make sure that the storedState in the cookie
        // matches that of the state in the request to /callback
        let state = functions.stateString(CONSTS.STATE_STR_LENGTH);
        
        console.log(`/setstate STATE: ${state}`);
        
        // Note that the interactions with `reply` need to be chained togheter
        // We (seemingly) can't send a reply with a Set-Cookie to the client and redirect at the same time
        // with fastify (possible with express) and therefore we redirect to a seperate route
        // were the redirection takes place after setting the cookie     
        reply.setCookie( CONSTS.state_cookie_key, state, 
        {  
            domain: CONSTS.base_uri.replace(/^https?:\/\//,'').replace(new RegExp( ":" + CONSTS.WEB_SERVICE_PORT + "$" ), ''),
            path: '/',
            signed: true,
        })
        .redirect(CONSTS.base_uri + '/authorize')

        //https://accounts.spotify.com/authorize?client_id=08c759bd98d149f58ce04c9caabb0f97%0A&redirect_uri=http%3A%2F%2Flocalhost%3A3443%2Fcallback&state=&scope=playlist-read-private%20streaming&response_type=code
    })
    
    //*** OAuth STEP 1 ***//
    fastify.get('/authorize', (request, reply) =>
    // Redirect to accounts.spotify after setting the state cookie under /setstate
    {
        // Recall that the key-name for the state value isn't just 'state' 
        let state = eval(`request.cookies.${CONSTS.state_cookie_key}`) || null;
        console.log(`/authorize STATE: ${state}`);

        if (state)
        {
            // We will need to include:
            //	* the `client_id` (of the app) so spotify knows what app the user is trying to use
            //	* the `redirect_uri` (/callback) which the user will be sent back to after successful authentication with spotfiy
            // 	* a random `state` string for security
            //	* a blankspace seperated list of scopes that the app will need to access
            // 	* `show_dialog` can be set to true (false is default) if the user should be prompted
            // 	to authorize the app anew every time they use it (set to true for testing)
            //  * `response_type`, set to 'code'

            // .stringify will produce a URL encoded string from a given JSON object
            reply.redirect( CONSTS.auth_endpoint + 
                queryString.stringify( 
                {
                    client_id: CONSTS.client_id,
                    redirect_uri: CONSTS.redirect_uri,
                    state: state,
                    scope: CONSTS.scope ,
                    response_type: 'code',
                    show_dialog: true
                }
            ));
        }
        // if no state has been set redirect back to /setstate
        else { reply.redirect('/setstate'); }
    })

    //*** OAuth STEP 2 ***//
    fastify.get('/callback', (request, reply) =>
    // After sending the user to accounts.spotify they will be redirected back here
    {
        if ( request.query.error ) { functions.errorRedirect(reply,request.query.error); }
        else
        {
            // If they accepted the request will contain:
            //	* code: The authrization code generated by spotify which we can exchange for a token
            // 	* state: The same state value that we sent in the first request

            // Extract the request paramaters and cookie value (if they exist)
            state = request.query.state || null;
            code = request.query.code || null;

            // x = A ? A : B
            // Assign A to x if A evaluates to true otherwise use B
            storedState = request.cookies ? request.cookies[CONSTS.state_cookie_key] : null;
            
            if ( storedState )
            {
                if ( state === storedState )
                {
                    reply.view("/templates/index.ejs" , { title: "Successful authorization" })
                }
                else { functions.errorRedirect(reply,"State mismatch"); }
            }
            else { functions.errorRedirect(reply,"No stored state in cookies!"); }
        }


    })

    fastify.get('/error', (request, reply) => 
    {
        // The .view object is supplied by point-of-view and is used
        // to parse inputs to the template engine
        reply.view('/templates/error.ejs', { error: request.query['error'] || "Unknown error" })
    })

    fastify.get('/', (request, reply) => 
    {
        // Static file serving
        reply.sendFile("index.html") 
    })

}


